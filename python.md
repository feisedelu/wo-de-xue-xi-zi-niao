# python

### 基础

​      	以`#`开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号`:`结尾时，缩进的语句视为代码块。Python程序是大小写敏感的，如果写错了大小写，程序会报错。

## 数据类型与变量

#### 整数

​		Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：`1`，`100`，`-8080`，`0`，等等。

​		计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用`0x`前缀和0-9，a-f表示，例如：`0xff00`，`0xa5b4c3d2`，等等。

​		对于很大的数，例如`10000000000`，很难数清楚0的个数。Python允许在数字中间以`_`分隔，因此，写成`10_000_000_000`和`10000000000`是完全一样的。十六进制数也可以写成`0xa1b2_c3d4`。

#### 浮点数

​		浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的。浮点数可以用数学写法，如`1.23`，`3.14`，`-9.01`，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，0.000012可以写成`1.2e-5`，等等。

​		整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

#### 字符串

字符串是以单引号`'`或双引号`"`括起来的任意文本，比如`'abc'`，`"xyz"`等等。请注意，`''`或`""`本身只是一种表示方式，不是字符串的一部分，因此，字符串`'abc'`只有`a`，`b`，`c`这3个字符。如果`'`本身也是一个字符，那就可以用`""`括起来，比如`"I'm OK"`包含的字符是`I`，`'`，`m`，空格，`O`，`K`这6个字符。

如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识。

转义字符`\`可以转义很多字符，比如`\n`表示换行，`\t`表示制表符，字符`\`本身也要转义，所以`\\`表示的字符就是`\`，

如果字符串里面有很多字符都需要转义，就需要加很多`\`，为了简化，Python还允许用`r''`表示`''`内部的字符串默认不转义

如果字符串内部有很多换行，用`\n`写在一行里不好阅读，为了简化，Python允许用`'''...'''`的格式表示多行内容

#### 布尔值

布尔值和布尔代数的表示完全一致，一个布尔值只有`True`、`False`两种值，要么是`True`，要么是`False`，在Python中，可以直接用`True`、`False`表示布尔值（请注意大小写）

布尔值可以用`and`、`or`和`not`运算。

`and`运算是与运算，只有所有都为`True`，`and`运算结果才是`True`：

`or`运算是或运算，只要其中有一个为`True`，`or`运算结果就是`True`：

`not`运算是非运算，它是一个单目运算符，把`True`变成`False`，`False`变成`True`：

布尔值经常用在条件判断中

#### 空值

空值是Python里一个特殊的值，用`None`表示。`None`不能理解为`0`，因为`0`是有意义的，而`None`是一个特殊的空值。

#### 变量

变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和`_`的组合，且不能用数字开头

在Python中，等号`=`是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量

#### 常量

所谓常量就是不能变的变量，在Python中，通常用全部大写的变量名表示常量：

在Python中，有两种除法，一种除法是`/`，`/`除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：还有一种除法是`//`，称为地板除，两个整数的除法仍然是整数：整数的地板除`//`永远是整数，即使除不尽。要做精确的除法，使用`/`就可以。

因为`//`除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：用的是%

### Python的字符串

对于单个字符的编码，Python提供了`ord()`函数获取字符的整数表示，`chr()`函数把编码转换为对应的字符：

由于Python的字符串类型是`str`，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把`str`变为以字节为单位的`bytes`。

Python对`bytes`类型的数据用带`b`前缀的单引号或双引号表示：

要注意区分`'ABC'`和`b'ABC'`，前者是`str`，后者虽然内容显示得和前者一样，但`bytes`的每个字符都只占用一个字节。

以Unicode表示的`str`通过`encode()`方法可以编码为指定的`bytes`

纯英文的`str`可以用`ASCII`编码为`bytes`，内容是一样的，含有中文的`str`可以用`UTF-8`编码为`bytes`。含有中文的`str`无法用`ASCII`编码，因为中文编码的范围超过了`ASCII`编码的范围，Python会报错。

在`bytes`中，无法显示为ASCII字符的字节，用`\x##`显示。

反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是`bytes`。要把`bytes`变为`str`，就需要用`decode()`的方法

如果`bytes`中只有一小部分无效的字节，可以传入`errors='ignore'`忽略错误的字节：

要计算`str`包含多少个字符，可以用`len()`函数：`len()`函数计算的是`str`的字符数，如果换成`bytes`，`len()`函数就计算字节数：

#### 格式化

在Python中，采用的格式化方式和C语言是一致的，用`%`实现。

```python
》》》, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'
```

如果你不太确定应该用什么，`%s`永远起作用，它会把任何数据类型转换为字符串：有些时候，字符串里面的`%`是一个普通字符怎么办？这个时候就需要转义，用`%%`来表示一个`%`

##### format()

另一种格式化字符串的方法是使用字符串的`format()`方法，它会用传入的参数依次替换字符串内的占位符`{0}`、`{1}`……，不过这种方式写起来比%要麻烦得多

##### f-string

最后一种格式化字符串的方法是使用以`f`开头的字符串，称之为`f-string`，它和普通字符串不同之处在于，字符串如果包含`{xxx}`，就会以对应的变量替换：

### list

Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。

```python
li = ['Michael', 'Bob', 'Tracy']
```

变量`li`就是一个list。用`len()`函数可以获得list元素的个数：

用索引来访问list中每一个位置的元素，记得索引是从`0`开始的：

当索引超出了范围时，Python会报一个`IndexError`错误，所以，要确保索引不要越界，记得最后一个元素的索引是`len(classmates) - 1`。

如果要取最后一个元素，除了计算索引位置外，还可以用`-1`做索引，直接获取最后一个元素：

list是一个可变的有序表，所以，可以往list中追加元素到末尾：用append（）

也可以把元素插入到指定的位置，比如索引号为`1`的位置用： insert(1, 'xxxx')

要删除list末尾的元素，用`pop()`方法：要删除指定位置的元素，用`pop(i)`方法，其中`i`是索引位置：

要把某个元素替换成别的元素，可以**直接赋值**给对应的索引位置：

list里面的元素的数据类型也可以不同

list元素也可以是另一个list，

#### list（）

把别的转换成list函数

### tuple

另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，而且用的是（）不是listde【】，不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。

如果要定义一个空的tuple，可以写成`()`：

只有1个元素的tuple定义时必须加一个逗号`,`，来消除歧义：

tuple内可以有list，而list是可以改变的

### intput

`input()`读取用户的输入，这样可以自己输入，程序运行得更有意思

intput的返回值类型是str

### 条件判断

根据Python的缩进规则，如果`if`语句判断是`True`，就把缩进的两行print语句执行了，否则，什么也不做。

也可以给`if`添加一个`else`语句，意思是，如果`if`判断是`False`，不要执行`if`的内容，去把`else`执行了：

注意不要少写了冒号`:`

可以用`elif`做更细致的判断：`elif`是`else if`的缩写，完全可以有多个`elif`

`if`判断条件还可以简写

### 循环

Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来

所以`for x in ...`循环就是把每个元素代入变量`x`，然后执行缩进块的语句。

`range()`函数，可以生成一个整数序列

第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环

### break

在循环中，`break`语句可以提前退出循环

### continue

在循环过程中，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环。

### dict

Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。如果用dict实现，只需要一个对照表无论这个表有多大，查找速度都不会变慢

例如：

```python
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
>>> d['Michael']
95
```

key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。

把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：

由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

如果key不存在，dict就会报错：

要避免key不存在的错误，有两种办法，一是通过`in`判断key是否存在：

二是通过dict提供的`get()`方法，如果key不存在，可以返回`None`，或者自己指定的value：

要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除：

dict内部存放的顺序和key放入的顺序是没有关系的。

和list比较，dict有以下几个特点：

1. 查找和插入的速度极快，不会随着key的增加而变慢；
2. 需要占用大量的内存，内存浪费多。

而list相反：

1. 查找和插入的时间随着元素的增加而增加；
2. 占用空间小，浪费内存很少。

### set

set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

通过`add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果：

通过`remove(key)`方法可以删除元素：

## 函数

### 直接调用的函数

`help()`查看函数的帮助信息。

求绝对值的函数`abs（）`

`max()`可以接收任意多个参数，并返回最大的那个：

`int()`函数可以把其他数据类型转换为整数：

### 定义函数

在Python中，定义一个函数要使用`def`语句，依次写出函数名、括号、括号中的参数和冒号`:`，然后，在缩进块中编写函数体，函数的返回值用`return`语句返回

例

def my_abs(x):
    if x >= 0:
        return x
    else:
        return -x

### 空函数

如果想定义一个什么事也不做的空函数，可以用`pass`语句：例

```python
def nop():
    pass
```

### 返回多个值

函数可以返回多个值吗？答案是肯定的。

比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：

`import math`语句表示导入`math`包，并允许后续代码引用`math`包里的`sin`、`cos`等函数。

但其实这只是一种假象，Python函数返回的仍然是单一值：

原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。

### 函数的参数

函数可以传入多个参数，也可以设置默认参数

例

```python
ef power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
```

设置默认参数时，有几点要注意：

一是必选参数在前，默认参数在后，否则Python的解释器会报错；

二是如何设置默认参数。

当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

默认参数必须指向不变对象

### 递归函数

例

```python
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```

解决递归调用栈溢出的方法是通过**尾递归**优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

例

```python
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```

